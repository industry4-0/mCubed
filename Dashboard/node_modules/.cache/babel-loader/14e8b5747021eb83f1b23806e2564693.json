{"ast":null,"code":"/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\n'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\GEORGE MANTAS\\\\Desktop\\\\dash\\\\Dashboard\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nfunction percent(covered, total) {\n  var tmp;\n\n  if (total > 0) {\n    tmp = 1000 * 100 * covered / total + 5;\n    return Math.floor(tmp / 10) / 100;\n  } else {\n    return 100.0;\n  }\n}\n\nfunction blankSummary() {\n  var empty = function empty() {\n    return {\n      total: 0,\n      covered: 0,\n      skipped: 0,\n      pct: 'Unknown'\n    };\n  };\n\n  return {\n    lines: empty(),\n    statements: empty(),\n    functions: empty(),\n    branches: empty()\n  };\n} // asserts that a data object \"looks like\" a summary coverage object\n\n\nfunction assertValidSummary(obj) {\n  var valid = obj && obj.lines && obj.statements && obj.functions && obj.branches;\n\n  if (!valid) {\n    throw new Error('Invalid summary coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\r\n * CoverageSummary provides a summary of code coverage . It exposes 4 properties,\r\n * `lines`, `statements`, `branches`, and `functions`. Each of these properties\r\n * is an object that has 4 keys `total`, `covered`, `skipped` and `pct`.\r\n * `pct` is a percentage number (0-100).\r\n * @param {Object|CoverageSummary} [obj=undefined] an optional data object or\r\n * another coverage summary to initialize this object with.\r\n * @constructor\r\n */\n\n\nfunction CoverageSummary(obj) {\n  if (!obj) {\n    this.data = blankSummary();\n  } else if (obj instanceof CoverageSummary) {\n    this.data = obj.data;\n  } else {\n    this.data = obj;\n  }\n\n  assertValidSummary(this.data);\n}\n\n['lines', 'statements', 'functions', 'branches'].forEach(function (p) {\n  Object.defineProperty(CoverageSummary.prototype, p, {\n    enumerable: true,\n    get: function get() {\n      return this.data[p];\n    }\n  });\n});\n/**\r\n * merges a second summary coverage object into this one\r\n * @param {CoverageSummary} obj - another coverage summary object\r\n */\n\nCoverageSummary.prototype.merge = function (obj) {\n  var _this = this;\n\n  var keys = ['lines', 'statements', 'branches', 'functions'];\n  keys.forEach(function (key) {\n    _this[key].total += obj[key].total;\n    _this[key].covered += obj[key].covered;\n    _this[key].skipped += obj[key].skipped;\n    _this[key].pct = percent(_this[key].covered, _this[key].total);\n  });\n  return this;\n};\n/**\r\n * returns a POJO that is JSON serializable. May be used to get the raw\r\n * summary object.\r\n */\n\n\nCoverageSummary.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * return true if summary has no lines of code\r\n */\n\n\nCoverageSummary.prototype.isEmpty = function () {\n  return this.lines.total === 0;\n}; // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath) {\n  return {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  var valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\r\n * provides a read-only view of coverage for a single file.\r\n * The deep structure of this object is documented elsewhere. It has the following\r\n * properties:\r\n *\r\n * * `path` - the file path for which coverage is being tracked\r\n * * `statementMap` - map of statement locations keyed by statement index\r\n * * `fnMap` - map of function metadata keyed by function index\r\n * * `branchMap` - map of branch metadata keyed by branch index\r\n * * `s` - hit counts for statements\r\n * * `f` - hit count for functions\r\n * * `b` - hit count for branches\r\n *\r\n * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\r\n * and empty coverage object with the specified file path or a data object that\r\n * has all the required properties for a file coverage object.\r\n * @constructor\r\n */\n\n\nfunction FileCoverage(pathOrObj) {\n  if (!pathOrObj) {\n    throw new Error('Coverage must be initialized with a path or an object');\n  }\n\n  if (typeof pathOrObj === 'string') {\n    this.data = emptyCoverage(pathOrObj);\n  } else if (pathOrObj instanceof FileCoverage) {\n    this.data = pathOrObj.data;\n  } else if (typeof pathOrObj === 'object') {\n    this.data = pathOrObj;\n  } else {\n    throw new Error('Invalid argument to coverage constructor');\n  }\n\n  assertValidObject(this.data);\n}\n/**\r\n * returns computed line coverage from statement coverage.\r\n * This is a map of hits keyed by line number in the source.\r\n */\n\n\nFileCoverage.prototype.getLineCoverage = function () {\n  var statementMap = this.data.statementMap;\n  var statements = this.data.s;\n  var lineMap = Object.create(null);\n  Object.keys(statements).forEach(function (st) {\n    if (!statementMap[st]) {\n      return;\n    }\n\n    var line = statementMap[st].start.line;\n    var count = statements[st];\n    var prevVal = lineMap[line];\n\n    if (prevVal === undefined || prevVal < count) {\n      lineMap[line] = count;\n    }\n  });\n  return lineMap;\n};\n/**\r\n * returns an array of uncovered line numbers.\r\n * @returns {Array} an array of line numbers for which no hits have been\r\n *  collected.\r\n */\n\n\nFileCoverage.prototype.getUncoveredLines = function () {\n  var lc = this.getLineCoverage();\n  var ret = [];\n  Object.keys(lc).forEach(function (l) {\n    var hits = lc[l];\n\n    if (hits === 0) {\n      ret.push(l);\n    }\n  });\n  return ret;\n};\n/**\r\n * returns a map of branch coverage by source line number.\r\n * @returns {Object} an object keyed by line number. Each object\r\n * has a `covered`, `total` and `coverage` (percentage) property.\r\n */\n\n\nFileCoverage.prototype.getBranchCoverageByLine = function () {\n  var branchMap = this.branchMap;\n  var branches = this.b;\n  var ret = {};\n  Object.keys(branchMap).forEach(function (k) {\n    var _ret$line;\n\n    var line = branchMap[k].line || branchMap[k].loc.start.line;\n    var branchData = branches[k];\n    ret[line] = ret[line] || [];\n\n    (_ret$line = ret[line]).push.apply(_ret$line, _toConsumableArray(branchData));\n  });\n  Object.keys(ret).forEach(function (k) {\n    var dataArray = ret[k];\n    var covered = dataArray.filter(function (item) {\n      return item > 0;\n    });\n    var coverage = covered.length / dataArray.length * 100;\n    ret[k] = {\n      covered: covered.length,\n      total: dataArray.length,\n      coverage: coverage\n    };\n  });\n  return ret;\n}; // expose coverage data attributes\n\n\n['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b'].forEach(function (p) {\n  Object.defineProperty(FileCoverage.prototype, p, {\n    enumerable: true,\n    get: function get() {\n      return this.data[p];\n    }\n  });\n});\n/**\r\n * return a JSON-serializable POJO for this file coverage object\r\n */\n\nFileCoverage.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * merges a second coverage object into this one, updating hit counts\r\n * @param {FileCoverage} other - the coverage object to be merged into this one.\r\n *  Note that the other object should have the same structure as this one (same file).\r\n */\n\n\nFileCoverage.prototype.merge = function (other) {\n  var _this2 = this;\n\n  Object.keys(other.s).forEach(function (k) {\n    _this2.data.s[k] += other.s[k];\n  });\n  Object.keys(other.f).forEach(function (k) {\n    _this2.data.f[k] += other.f[k];\n  });\n  Object.keys(other.b).forEach(function (k) {\n    var i;\n    var retArray = _this2.data.b[k];\n    var secondArray = other.b[k];\n\n    if (!retArray) {\n      _this2.data.b[k] = secondArray;\n      return;\n    }\n\n    for (i = 0; i < retArray.length; i += 1) {\n      retArray[i] += secondArray[i];\n    }\n  });\n};\n\nFileCoverage.prototype.computeSimpleTotals = function (property) {\n  var stats = this[property];\n  var ret = {\n    total: 0,\n    covered: 0,\n    skipped: 0\n  };\n\n  if (typeof stats === 'function') {\n    stats = stats.call(this);\n  }\n\n  Object.keys(stats).forEach(function (key) {\n    var covered = !!stats[key];\n    ret.total += 1;\n\n    if (covered) {\n      ret.covered += 1;\n    }\n  });\n  ret.pct = percent(ret.covered, ret.total);\n  return ret;\n};\n\nFileCoverage.prototype.computeBranchTotals = function () {\n  var stats = this.b;\n  var ret = {\n    total: 0,\n    covered: 0,\n    skipped: 0\n  };\n  Object.keys(stats).forEach(function (key) {\n    var branches = stats[key];\n    var covered;\n    branches.forEach(function (branchHits) {\n      covered = branchHits > 0;\n\n      if (covered) {\n        ret.covered += 1;\n      }\n    });\n    ret.total += branches.length;\n  });\n  ret.pct = percent(ret.covered, ret.total);\n  return ret;\n};\n/**\r\n * resets hit counts for all statements, functions and branches\r\n * in this coverage object resulting in zero coverage.\r\n */\n\n\nFileCoverage.prototype.resetHits = function () {\n  var statements = this.s;\n  var functions = this.f;\n  var branches = this.b;\n  Object.keys(statements).forEach(function (s) {\n    statements[s] = 0;\n  });\n  Object.keys(functions).forEach(function (f) {\n    functions[f] = 0;\n  });\n  Object.keys(branches).forEach(function (b) {\n    var hits = branches[b];\n    branches[b] = hits.map(function () {\n      return 0;\n    });\n  });\n};\n/**\r\n * returns a CoverageSummary for this file coverage object\r\n * @returns {CoverageSummary}\r\n */\n\n\nFileCoverage.prototype.toSummary = function () {\n  var ret = {};\n  ret.lines = this.computeSimpleTotals('getLineCoverage');\n  ret.functions = this.computeSimpleTotals('f', 'fnMap');\n  ret.statements = this.computeSimpleTotals('s', 'statementMap');\n  ret.branches = this.computeBranchTotals();\n  return new CoverageSummary(ret);\n};\n\nmodule.exports = {\n  CoverageSummary: CoverageSummary,\n  FileCoverage: FileCoverage\n};","map":null,"metadata":{},"sourceType":"script"}