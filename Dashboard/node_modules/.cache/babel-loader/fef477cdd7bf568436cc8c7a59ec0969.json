{"ast":null,"code":"/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\n'use strict';\n\nvar FileCoverage = require('./file').FileCoverage;\n\nvar CoverageSummary = require('./file').CoverageSummary;\n\nfunction loadMap(source) {\n  var data = Object.create(null);\n  Object.keys(source).forEach(function (k) {\n    var cov = source[k];\n\n    if (cov instanceof FileCoverage) {\n      data[k] = cov;\n    } else {\n      data[k] = new FileCoverage(cov);\n    }\n  });\n  return data;\n}\n/**\r\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\r\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\r\n * map's contents. This can be the raw global coverage object.\r\n * @constructor\r\n */\n\n\nfunction CoverageMap(obj) {\n  if (!obj) {\n    this.data = Object.create(null);\n  } else if (obj instanceof CoverageMap) {\n    this.data = obj.data;\n  } else {\n    this.data = loadMap(obj);\n  }\n}\n/**\r\n * merges a second coverage map into this one\r\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\r\n *  correctly for the same files and additional file coverage keys are created\r\n *  as needed.\r\n */\n\n\nCoverageMap.prototype.merge = function (obj) {\n  var _this = this;\n\n  var other;\n\n  if (obj instanceof CoverageMap) {\n    other = obj;\n  } else {\n    other = new CoverageMap(obj);\n  }\n\n  Object.keys(other.data).forEach(function (k) {\n    var fc = other.data[k];\n\n    if (_this.data[k]) {\n      _this.data[k].merge(fc);\n    } else {\n      _this.data[k] = fc;\n    }\n  });\n};\n/**\r\n * filter the coveragemap based on the callback provided\r\n * @param {Function (filename)} callback - Returns true if the path\r\n *  should be included in the coveragemap. False if it should be\r\n *  removed.\r\n */\n\n\nCoverageMap.prototype.filter = function (callback) {\n  var _this2 = this;\n\n  Object.keys(this.data).forEach(function (k) {\n    if (!callback(k)) {\n      delete _this2.data[k];\n    }\n  });\n};\n/**\r\n * returns a JSON-serializable POJO for this coverage map\r\n * @returns {Object}\r\n */\n\n\nCoverageMap.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * returns an array for file paths for which this map has coverage\r\n * @returns {Array{string}} - array of files\r\n */\n\n\nCoverageMap.prototype.files = function () {\n  return Object.keys(this.data);\n};\n/**\r\n * returns the file coverage for the specified file.\r\n * @param {String} file\r\n * @returns {FileCoverage}\r\n */\n\n\nCoverageMap.prototype.fileCoverageFor = function (file) {\n  var fc = this.data[file];\n\n  if (!fc) {\n    throw new Error('No file coverage available for: ' + file);\n  }\n\n  return fc;\n};\n/**\r\n * adds a file coverage object to this map. If the path for the object,\r\n * already exists in the map, it is merged with the existing coverage\r\n * otherwise a new key is added to the map.\r\n * @param {FileCoverage} fc the file coverage to add\r\n */\n\n\nCoverageMap.prototype.addFileCoverage = function (fc) {\n  var cov = new FileCoverage(fc);\n  var path = cov.path;\n\n  if (this.data[path]) {\n    this.data[path].merge(cov);\n  } else {\n    this.data[path] = cov;\n  }\n};\n/**\r\n * returns the coverage summary for all the file coverage objects in this map.\r\n * @returns {CoverageSummary}\r\n */\n\n\nCoverageMap.prototype.getCoverageSummary = function () {\n  var _this3 = this;\n\n  var ret = new CoverageSummary();\n  this.files().forEach(function (key) {\n    ret.merge(_this3.fileCoverageFor(key).toSummary());\n  });\n  return ret;\n};\n\nmodule.exports = {\n  CoverageMap: CoverageMap\n};","map":null,"metadata":{},"sourceType":"script"}